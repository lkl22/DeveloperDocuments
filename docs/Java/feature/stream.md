# Stream

* [简介](#简介)
* [获取流](#获取流)
* [流操作和管道](#流操作和管道)
  * [操作状态](#操作状态)
  * [短路操作](#短路操作)
* [并行性](#并行性)
* [参考文献](#参考文献)

## 简介

Java 8 API添加了一个支持对元素流进行函数式操作的类 `Stream`，可以让你以一种声明的方式处理数据。

`Stream` 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 `Java` 集合运算和表达的高阶抽象。

> Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。

这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。

元素流在管道中经过 `中间操作（intermediate operation）` 的处理，最后由 `终端操作(terminal operation)` 得到前面处理的结果。

For example:

```java
int sum = widgets.stream()
                 .filter(b -> b.getColor() == RED)
                 .mapToInt(b -> b.getWeight())
                 .sum();
```

流与集合的不同点：

* **没有存储。流不是存储元素的数据结构**；相反，它通过计算操作的管道传送来自数据结构、数组、生成器函数或 I/O 通道等源的元素。
* **功能性。对流的操作会产生结果，但不会修改其源**。例如，过滤从集合中获取的 `Stream` 会生成一个没有过滤元素的新 `Stream`，而不是从源集合中删除元素。
* **延迟执行**。许多流操作，例如过滤、映射或重复删除，可以延迟执行，从而暴露优化机会。例如，“找到第一个具有三个连续元音的String”不需要检查所有输入字符串。流操作分为`中间（Stream-producing）操作`和 `终端（value- or side-effect-producing）操作`。**中间操作总是懒惰的**。
* **可能无界。虽然集合具有有限的大小，但流不需要**。诸如 `limit(n)` 或 `findFirst()` 之类的短路操作可以允许在有限时间内完成对无限流的计算。
* **消耗品。流的元素在流的生命周期内仅被访问一次**。与 `Iterator` 一样，必须生成新的流以重新访问源的相同元素。

## 获取流

可以通过多种方式获得流：

* 从一个 `Collection` 的 `stream()` 和 `parallelStream()` 方法；
* 从一个数组通过 `Arrays.stream(Object[])`;
* 来自流类上的静态工厂方法，例如 `Stream.of(Object[])`, `IntStream.range(int, int)` 或 `Stream.iterate(Object, UnaryOperator)`;
* 文件的行可以从 `BufferedReader.lines()` 获得;
* 文件路径流可以从 `Files` 中的方法获得；
* 可以从 `Random.ints()` 获得随机数流；
* JDK 中的许多其他流承载方法，包括 `BitSet.stream()`、`Pattern.splitAsStream(java.lang.CharSequence)` 和 `JarFile.stream()`。

## 流操作和管道

**流操作分为中间操作和终端操作，结合起来形成流管道**。 流管道由源（例如集合、数组、生成器函数或 I/O 通道）组成； 后跟零个或多个中间操作，例如 `Stream.filter` 或 `Stream.map`； 和一个终端操作，如 `Stream.forEach` 或 `Stream.reduce`。

中间操作返回一个新的流。 他们总是很 lazy； 执行诸如 `filter()` 之类的中间操作实际上并不执行任何过滤，而是创建一个新流，该流在遍历时包含与给定谓词匹配的初始流的元素。 **管道源的遍历直到管道的终端操作被执行后才开始**。

诸如 `Stream.forEach` 或 `IntStream.sum` 之类的终端操作可能会遍历流以产生结果或 side-effect。**执行完终端操作后，流管道被认为已消耗，不能再使用**；如果需要再次遍历同一个数据源，必须返回数据源获取新的流。**在几乎所有情况下，终端操作都是急切的，在返回之前完成对数据源的遍历和管道的处理**。只有终端操作 `iterator()` 和 `spliterator()` 不是；这些是作为“逃生舱口”提供的，以便在现有操作不足以完成任务的情况下启用任意客户端控制的管道遍历。

延迟处理流可以显著提高效率； 在诸如上面的 `filter-map-sum` 示例之类的管道中，过滤、映射和求和可以融合到数据上的单次传递中，中间状态最少。 **Laziness 还可以避免在不必要时检查所有数据**； 对于诸如“查找第一个长度超过 1000 个字符的字符串”之类的操作，只需检查足够多的字符串即可找到具有所需特征的字符串，而无需检查源中所有可用的字符串。 （当输入流是无限的而不仅仅是大时，这种行为变得更加重要。）

### 操作状态

**中间操作进一步分为无状态操作和有状态操作**。

* 无状态操作，例如 `filter` 和 `map`，在处理新元素时不保留先前看到的元素的状态——每个元素都可以独立于其他元素的操作进行处理。
* 在处理新元素时，有状态的操作，例如 `distinct` 和 `sorted`，可能会合并以前看到的元素的状态。

有状态操作可能需要在产生结果之前处理整个输入。例如，在看到流的所有元素之前，无法通过对流进行排序来产生任何结果。因此，在并行计算下，一些包含有状态中间操作的管道可能需要对数据进行多次传递，或者可能需要缓冲重要数据。

包含完全无状态中间操作的管道可以在单次通过中处理，无论是顺序的还是并行的，数据缓冲最少。

### 短路操作

此外，一些操作被视为短路操作。 

* 如果中间操作在呈现无限输入时可能因此产生有限流，则它是短路的。 
* 如果终端操作在无限输入时可能在有限时间内终止，则它是短路的。 

> 在管道中进行短路操作是无限流处理在有限时间内正常终止的必要条件，但不是充分条件。

## 并行性

具有显式 for 循环的处理元素本质上是串行的。 **流通过将计算重新构建为聚合操作的管道而不是每个单独元素上的命令式操作来促进并行执行**。 所有流操作都可以串行或并行执行。 除非明确请求并行性，否则 JDK 中的流实现会创建串行流。 例如，`Collection` 有 `Collection.stream()` 和 `Collection.parallelStream()` 方法，它们分别产生顺序流和并行流； 其他流承载方法，如 `IntStream.range(int, int)` 产生顺序流，但这些流可以通过调用它们的 `BaseStream.parallel()` 方法有效地并行化。 要并行执行先前的“sum of weights of widgets”查询，我们将执行以下操作：

```java
int sumOfWeights = widgets.parallelStream()
                          .filter(b -> b.getColor() == RED)
                          .mapToInt(b -> b.getWeight())
                          .sum();
```

此示例的串行和并行版本之间的唯一区别是创建初始流，使用“`parallelStream()`”而不是“`stream()`”。当启动终端操作时，流管道将根据调用它的流的方向顺序或并行执行。可以使用 `isParallel()` 方法确定流是串行执行还是并行执行，并且可以使用 `BaseStream.sequential()` 和 `BaseStream.parallel()` 操作修改流的方向。**当启动终端操作时，流管道将根据调用它的流的模式顺序或并行执行**。

> 除了标识为显式不确定的操作（例如 `findAny()`）之外，流是顺序执行还是并行执行不应改变计算结果。

大多数流操作接受描述用户指定行为的参数，这些参数通常是 lambda 表达式。 为了保持正确的行为，这些行为参数必须是无干扰的，并且在大多数情况下必须是无状态的。 此类参数始终是函数式接口（例如 Function）的实例，并且通常是 lambda 表达式或方法引用。

## 参考文献

[https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html](https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html)
